%{
#include <stdio.h>
#include "util.h"
#include "errormsg.h"

int yylex(void); /* function prototype */

A_exp absyn_root;

void yyerror(char *s)
{
 EM_error(EM_tokPos, "%s", s);
}
%}


%union {
	int pos;
	int ival;
	string sval;
	
	A_exp exp;

	}

%token <sval> ID 
%token <ival> INT 
%token <sval> STRING

%nonassoc IF THEN WHILE DO FOR TO
%left ELSE
%nonassoc ASSIGN 
%left OR AND
%nonassoc EQ NEQ GT LT GE LE
%left PLUS MINUS 
%left TIMES DIVIDE

%token 
  COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK 
  LBRACE RBRACE DOT 
  PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE
  AND OR ASSIGN
  ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF 
  BREAK NIL
  FUNCTION VAR TYPE 

%start program

%%

program:    exp
;


decs:       /* empty */
|           dec decs
;

dec:        tydec
|           vardec
|           fundec
;

tydec:      TYPE typeid EQ ty							
;

ty:         typeid
|           LBRACE tyfields RBRACE
|           ARRAY OF typeid
;

tyfields:   /* empty */
|           ID COLON typeid
|           ID COLON typeid COMMA tyfields
;

typeid:     ID
;

vardec:     VAR ID ASSIGN exp
|           VAR ID COLON typeid ASSIGN exp
;

fundec:     FUNCTION ID LPAREN tyfields RPAREN EQ exp
|           FUNCTION ID LPAREN tyfields RPAREN COLON typeid EQ exp
;


letblock:   LET decs IN exps END		{$$ = A_LetExp(EM_tokPos, $2, $4);}
;

whileblock: WHILE exp DO exp			{$$ = A_WhileExp(EM_tokPos, $2, $4);}
;


ifblock:    IF exp THEN exp 			{$$ = A_IfExp(EM_tokPos, $2, $4);}
|	    IF exp THEN exp ELSE exp		{$$ = A_IfExp(EM_tokPos, $2, $4, $6);}
;


forblock:   FOR ID ASSIGN exp TO exp DO exp	{$$ = A_ForExp(EM_tokPos, $2, $4, $6, $8);}
;


expseq: LPAREN exps RPAREN
;

exps:       exp
|           exps SEMICOLON exp
;

args:       exp
|           exp COMMA args
;

lvalue:     ID DOT lvalue
|	        ID brkchain
;

brkchain:   /*empty*/
|           LBRACK exp RBRACK brkchain
|           LBRACK exp RBRACK DOT lvalue
;

record:     ID EQ exp
|           ID EQ exp COMMA record
;

arrcreate:  ID LBRACK exp RBRACK OF exp		{$$ = A_ArrayExp(EM_tokPos, $3, $6);}

exp:        letblock
|           whileblock
|           ifblock
|           forblock
|           BREAK				{$$ = A_BreakExp(EM_tokPos);}
|           dec
|           ID LBRACE record RBRACE        // for record creation
|           ID LBRACE RBRACE
|           arrcreate                // array creation
|           lvalue ASSIGN exp			{$$ = A_AssignExp(EM_tokPos, $1, $3);}
|           bool
;       

bool:       bool AND comp        // TODO: better precedence names
|           bool OR comp
|           comp
;

comp:       sumop EQ sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop NEQ sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop LT sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop LE sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop GT sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop GE sumop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           sumop					
;

sumop:      sumop PLUS multop      		{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}      
|           sumop MINUS multop			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           multop
;

multop:     multop TIMES neg			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           multop DIVIDE neg			{$$ = A_OpExp(EM_tokPos, $2, $1, $3);}
|           neg
;

neg:        MINUS term				{$$ = A_OpExp(EM_tokPos, A_IntExp(EM_tokPos, 0), $1, $2);}
|           term
;

term:       INT					{$$ = A_IntExp(EM_tokPos, $1); }
|           STRING				{$$ = A_StringExp(EM_tokPos, $1);}
|           lvalue
|           NIL					{$$ = A_NilExp(EM_tokPos); }
|           expseq                  // also counts for (exp)
|           ID LPAREN RPAREN
|           ID LPAREN args RPAREN
|           LPAREN RPAREN           // empty expression
;
